{"timestamp":"1433963987","author":"bstanley@google.com","description":"A couple of questions."}

{"timestamp":"1433963987","author":"bstanley@google.com","location":{"commit":"2ea454c78e13a6e01d50e59aee4cfb800eedc993","path":"src/mirror/mirror.go","range":{"startLine":60}},"description":"I wouldn't have guessed that this code does what the comment says."}

{"timestamp":"1433963987","author":"bstanley@google.com","location":{"commit":"2ea454c78e13a6e01d50e59aee4cfb800eedc993","path":"src/mirror/mirror.go","range":{"startLine":48}},"description":"Do we need to support multiple timers per repo?"}

{"timestamp":"1433968905","author":"ojarjur@google.com","location":{"commit":"2ea454c78e13a6e01d50e59aee4cfb800eedc993","path":"src/mirror/mirror.go","range":{"startLine":48}},"description":"On second thought, we don't even really *need* multiple timers at all.\n\nI'm going to change this to use a single global timer."}

{"timestamp":"1433968905","author":"ojarjur@google.com","location":{"commit":"2ea454c78e13a6e01d50e59aee4cfb800eedc993","path":"src/mirror/mirror.go","range":{"startLine":60}},"description":"Yeah, I was trying to both be go-idiomatic (where rate limiting is done using a \"time.Tick\" channel) and not have to either drastically restructure the code or rate-limit all of the repos as a group.\n\nHowever, thinking through it again, I don't think the added complexity is worth it. I'm going to change the rate-limiting to be done one level up, and have a single ticker that is used for the over-arching for-loop."}

{"timestamp":"1434042310","author":"amshali@google.com","location":{"commit":"d03068138180fafd930878e24f5787c805893692","path":"src/main.go","range":{"startLine":72}},"description":"What's the point of this flag here? If flag is false we will busy loop here on findRepos and mirroring them? It seems to me like we *always* need to have this ticking.  "}

{"timestamp":"1434042711","author":"ojarjur@google.com","location":{"commit":"d03068138180fafd930878e24f5787c805893692","path":"src/main.go","range":{"startLine":72}},"description":"That flag indicates that we are pushing to/pulling from a remote repo. If we aren't doing that, then all of the mirroring consists of local git operations, so there's no need to throttle."}

{"timestamp":"1434043218","author":"amshali@google.com","resolved":true}

{"timestamp":"1434043218","author":"amshali@google.com","location":{"commit":"d03068138180fafd930878e24f5787c805893692","path":"src/main.go","range":{"startLine":72}},"description":"My problem is with busy looping here when we do not pull/push to remote. It might not manifest itself because git operations are slow, but still I think it's a good idea to \"throttle\" here. Just my 2 cents."}

{"timestamp":"1434051069","author":"ojarjur@google.com","location":{"commit":"d03068138180fafd930878e24f5787c805893692","path":"src/main.go","range":{"startLine":72}},"description":"I don't think \"busy loop\" is a fair description, since the loop actually does work, it's just that some iterations (prossibly most) will be no-ops. At the very least, throttling the loop iterations doesn't change the fact that some of them would be no-ops, it just reduces the proportion that are.\n\nAt a less \"arguing over semantics\" level, the reason to throttle is if we want to save some resource at the expense of higher latency for mirroring. I wasn't doing the throttling when there is no syncing, as the only resource it would save is CPU, and I think spending the CPU cycles is worth the lower mirroring latency."}
